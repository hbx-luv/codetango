import {Component, ElementRef, Input, OnChanges, OnInit, ViewChild} from '@angular/core';
import {Observable} from 'rxjs';
import {tap} from 'rxjs/operators';
import {AuthService} from 'src/app/services/auth.service';
import {MessageService} from 'src/app/services/message.service';
import {Sound, SoundService} from 'src/app/services/sound.service';
import {UtilService} from 'src/app/services/util.service';
import {Game, Message, TeamType} from 'types';

@Component({
  selector: 'app-chat-box',
  templateUrl: './chat-box.component.html',
  styleUrls: ['./chat-box.component.scss'],
})
export class ChatBoxComponent implements OnInit, OnChanges {
  @ViewChild('scrollMe') private myScrollContainer: ElementRef;
  @Input() game: Game;

  newMessage: string;
  messages$: Observable<Message[]>;

  constructor(
      public readonly authService: AuthService,
      public readonly messageService: MessageService,
      private readonly utilService: UtilService,
      private readonly soundService: SoundService,
  ) {
    // scroll the chat box to the bottom when the shown state is toggled
    this.messageService.chatShown$.subscribe(() => this.scrollToBottom(300));
  }

  ngOnInit() {
    this.messages$ =
        this.messageService.getSpymasterMessages(this.game.id)
            .pipe(tap(messages => {
              if (messages && messages.length) {
                const lastMessage = messages[messages.length - 1];

                // don't let the chat box make sounds on the first load
                if (this.messageService.unreadMessages === undefined) {
                  this.messageService.unreadMessages = 0;
                }

                // badge and play sound when the chat box is not shown so long
                // as the incoming message isn't generated by the server
                else if (
                    !this.messageService.chatShown && !lastMessage.fromServer) {
                  this.messageService.unreadMessages++;
                  this.soundService.play(Sound.NEW_MESSAGE);
                }

                this.scrollToBottom();
              }
            }));
  }

  ngOnChanges() {
    if (this.game.completedAt) {
      this.messageService.chatShown = true;
    }
  }

  get placeholder(): string {
    return this.game && this.game.completedAt ?
        'This is the spymaster chat' :
        'Click here to chat with the other spymaster';
  }

  toggleChat() {
    // smaller displays show all of the messages all of the time on the chat
    // tab, so only allow toggling when the on bigger displays
    if (this.isBiggerDevice()) {
      this.messageService.toggleChatShown();
    }
  }

  sendMessage() {
    // when the game is over, just toast and don't send the message
    if (this.game.completedAt) {
      this.utilService.showToast(
          'Messages cannot be sent after the game is over');
    }

    // when the game is ongoing, messages will be sent in the chat
    else {
      const {currentUserId: userId} = this.authService;
      const team = this.game.blueTeam.userIds.includes(userId) ? TeamType.BLUE :
                                                                 TeamType.RED;

      this.messageService.sendSpymasterMessage(this.game.id, {
        text: this.newMessage,
        userId,
        team,
      });
    }

    delete this.newMessage;
  }

  scrollToBottom(timeout = 0): void {
    setTimeout(() => {
      try {
        this.myScrollContainer.nativeElement.scrollTop =
            this.myScrollContainer.nativeElement.scrollHeight;
      } catch (err) {
        // do nothing, this is ok
      }
    }, timeout);
  }

  private isBiggerDevice() {
    return window.innerWidth > 1040;
  }
}
